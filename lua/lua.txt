Programovací jazyk Lua
======================
■ Autor    Pavel Tišnovský, Red Hat
■ Email    <ptisnovs 0x40 redhat 0x2e com>
■ Datum    2015-11-19

Obsah přednášky (1)
-------------------------------
Vznik jazyka Lua, verze Luy
Použití jazyka Lua v SW projektech
Syntaxe a sémantika jazyka Lua

Vznik jazyka Lua
----------------------------------
1993 PETROBRAS (brazilská ropná společnost)
Několik projektů
    DEL - Data Entry Lanugage
    +
    SOL - Simple Object Language
    =
    Lua
Původně velmi jednoduchý skriptovací jazyk
Postupně rozšiřován o další vlastnosti

Verze Luy
----------------------------------
Lua 1.0   1993  nikdy nezveřejněna
Lua 1.1   1994  striktní licence
                volné použití jen pro akademickou sféru
Lua 2.1   1995  volné využití i v komerční sféře
Lua 3.0   1997  tag methods, auxlib
Lua 3.1   1998  anonymní funkce, uzávěry
Lua 4.0   2000  for cyklus
Lua 5.0   2003  koprogramy
Lua 5.1 * 2006  systém modulů
Lua 5.2 * 2011  příkaz GOTO :-) a finalizátory pro tabulky
Lua 5.3 * 2015  integer typy, bitové operátory

Použití jazyka Lua v SW projektech
----------------------------------
Skriptovací jazyk pro různé aplikace
    Zvětšení binárního souboru o cca 70kB
    přidáním interpretru a běhového prostředí
    Rozhraní Lua <=> C relativně snadné
    LuaFFI
Skriptovací jazyk pro hry
    https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games
    Baldur's Gate
    S.T.A.L.K.E.R. (všechny tři díly)
    World of Warcraft
    The Secret World
    BZflag
    atd. atd.
Jazyk pro embedded zařízení
    Malý runtime
    Poměrně rychlý běh
    Jedna z aplikací na mikrořadiči s 64kB RAM a 256kB EPROM
Obecný skriptovací jazyk
Lua na webových stránkách
    lua2js
    lua.vm.js

Základní vlastnosti jazyka Lua
------------------------------
Velmi jednoduchá syntaxe a sémantika
    Inspirace v Pascalu, Module, Pythonu
    Není nutné používat středníky
    Klíčová slova pro zápis řídicích konstrukcí (ne {})
Přenositelnost
    Překladač i interpret v čistém ANSI C
Rychlost překladu i interpretace bajtkódu
    Překlad až 6x rychlejší oproti Perlu a 8x oproti Pythonu
Funkcionální programování
    Funkce jako plnohodnotný datový typ
    Uzávěry
Rozšiřování možností jazyka
    Metatabulky

Syntaxe a sémantika jazyka Lua
==============================

Klíčová slova
-------------
and             function        repeat
break           goto            return
do              if              then
else            in              true
elseif          local           until
end             nil             while
false           not
for             or

Další tokeny rozpoznávané jazykem
---------------------------------
+     -     *     /     %     ^     #
&     ~     |     <<    >>    //
==    ~=    <=    >=    <     >     =
(     )     {     }     [     ]     ::
;     :     ,     .     ..    ...

Komentáře
---------
-- jednořádkový komentář
--[[
     víceřádkový
     komentář
]]--

Podporované datové typy
-----------------------
nil
        datový typ hodnoty nil
        je v celém programu jedinečná
        tato hodnota se definitoricky odlišuje od všech ostatních hodnot
boolean
        datový typ pravdivostních hodnot true a false
number
        reálné číslo podle IEEE 754 s dvojnásobnou přesností
        (v céčku či Javě se jedná o typ double)
        při překladu jazyka je však možné tento typ změnit
        nově i další subtyp: integer
string
        řetězec (částečná podpora UTF-8)
function
        buď vytvořená přímo ve skriptu či zaregistrovaná céčková funkce
        plnohodnotný datový typ
userdata
        data vytvořená v hostitelském (céčkovém) programu
thread
        vlákno použité pro implementaci koprogramů (coroutine)
table
        asociativní pole
        flexibilní datový typ, na kterém je založena většina
        funkcionality jazyka Lua, včetně objektového systému
        (v asociativním poli mohou být umístěny mj. i funkce)

Funkce jako plnohodnotný datový typ
-----------------------------------
funkce=print               -- promennym lze priradit i funkci
print("funkce=", funkce)
funkce(42)

print=1                    -- pozor! prepis globalniho objektu (zde funkce)
                           -- legalni, nicmene zpusobi problemy dale
print("dofile=", print)    -- nyni jiz funkce print neni dostupna

Globální objekty a funkce, které není vhodné přepisovat
-------------------------------------------------------
_G                    loadfile           require
_VERSION              loadstring         select
assert                module             setfenv
collectgarbage        next               setmetatable
dofile                pairs              tonumber
error                 pcall              tostring
getfenv               print              type
getmetatable          rawequal           unpack
ipairs                rawget             xpcall
load                  rawset

Přiřazení
---------
i,j=10,20                  -- vicenasobne prirazeni
print("i=", i)
print("j=", j)
--
i,j=j,i                    -- prohozeni obsahu dvou promennych
print("i=", i)
print("j=", j)

Bloky a viditelnost proměnných
------------------------------
x=10                              -- vytvoreni globalni promenne x
print("globalni x=", x)
--
do                                -- zacatek bloku
    local x=20                    -- vytvoreni lokalni promenne x
    print("1. lokalni x=", x)
    do                            -- zacatek zanoreneho bloku
        local x=30                -- vytvoreni lokalni promenne x
        print("2. lokalni x=", x)
    end                           -- konec zanoreneho bloku
    print("1. lokalni x=", x)
end                               -- konec bloku
--
print("globalni x=", x)

Podmínky
--------
if výraz then
    programový blok vykonaný při splnění podmínky
end
--
if výraz then
    programový blok vykonaný při splnění podmínky
else
    programový blok vykonaný při nesplnění podmínky
end

Podmínky
--------
if výraz then
    programový blok vykonaný při splnění první podmínky
elseif výraz then
    programový blok vykonaný při splnění druhé podmínky
elseif výraz then
    programový blok vykonaný při splnění třetí podmínky
else
    programový blok vykonaný při nesplnění podmínky
end

Programové smyčky: while
------------------------
while podmínka do
    programový blok vykonaný při splnění první podmínky
end
--
-- vypocet Fibonacciho posloupnosti az do mezni hodnoty
n = 1000
a, b = 1, 1
while a <= n do
    print(a)
    a, b = b, a+b
end

Programové smyčky: repeat-until
-------------------------------
-- vypocet Fibonacciho posloupnosti az do mezni hodnoty
n = 1000
a, b = 1, 1
repeat
    print(a)
    a, b = b, a+b
until a > n

Programové smyčky: for (počítaná)
---------------------------------
for prom=x1, x2 do
    blok příkazů umístěný v těle smyčky
end
--
for prom=x1, x2, krok do
    blok příkazů umístěný v těle smyčky
end
--
function star(step1, step2)
    for i=0, 35 do
        for j=0, 6 do
            left(2*360/7)
            forward(step1)
        end
        left(step2)
    end
end

Programové smyčky: for-each
---------------------------
for namelist in explist do
    blok příkazů umístěný v těle smyčky
end
--
months={"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"}
--
for poradi,month in pairs(months) do
    print(poradi, month)
end

Aritmetické operátory
---------------------
Symbol operátoru   Arita      Popis
+                  binární    součet
-                  binární    rozdíl
*                  binární    součin
/                  binární    podíl (reálná čísla)
%                  binární    dělení modulo
^                  binární    umocňování
-                  unární     unární minus

Logické operátory
-----------------
Symbol operátoru   Arita      Popis
and                binární    logický součin
or                 binární    logický součet
not                unární     logická negac

Relační operátory
-----------------
Symbol operátoru   Arita      Popis
==                 binární    rovnost
~=                 binární    nerovnost
<                  binární    menší než
>                  binární    větší než
<=                 binární    menší nebo rovno
>=                 binární    větší nebo rovno

Další operátory
---------------
Symbol operátoru   Arita      Popis
..                 binární    spojení dvou řetězců nebo
                              číslic převedených na řetězec
#                  unární     délka řetězce nebo velikost
                              asociativního pole

Priority operátorů
------------------
Priorita        Operátory
1 (nejvyšší)    ^
2               not # unární minus (-)
3               * / %
4               + -
5               ..
6               == ~= < > <= >=
7               and
8 (nejnižší)    or

Pole a asociativní pole
-----------------------
pole={"hodnota1", "hodnota2", "hodnota3"}
pole={klic1="hodnota1", klic2="hodnota2"}
pole={klic1="hodnota1", klic2="hodnota2",}
--
for klic,hodnota in pairs(pole) do
    print(klic, hodnota)
end

Pole a asociativní pole
-----------------------
pole={klic1="hodnota1", "hodnota2", klic2="hodnota3", "hodnota4"}
--
print(pole["klic1"])
print(pole["klic2"])
print(pole["klic3"]) -- neexistujici prvek, vypise se "nil"
print(pole.klic1)
print(pole.klic2)
print(pole.klic3)    -- neexistujici prvek, vypise se "nil"

Funkce
------
-- funkce obsahujici lokalni promennou
function printHello()
    local helloStr = "Hello"
    print(helloStr)
end
--
worldStr="World"
--
-- funkce vyuzivajici globalni promennou
function printWorld()
    -- ke globalni promenne je pripojena
    -- retezcova konstanta (literal)
    print(worldStr .. "!")
end
--
-- volani obou funkci
printHello()
printWorld()
--
-- zmena globalni promenne
-- se projevi i ve volane funkci
worldStr = 42
printWorld()

Funkce
------
-- definice vlastnich funkci bez vyuziti
-- "syntaktickeho cukru"
--
-- funkce obsahujici lokalni promennou
-- (hodnota typu funkce je prirazena
--  promenne pojmenovane "printHello")
printHello = function()
    local helloStr = "Hello"
    print(helloStr)
end
--
worldStr="World"
--
-- funkce vyuzivajici globalni promennou
-- (hodnota typu funkce je prirazena
--  promenne pojmenovane "printWorld")
printWorld = function()
    -- ke globalni promenne je pripojena
    -- retezcova konstanta (literal)
    print(worldStr .. "!")
end
--
-- volani obou funkci
printHello()
printWorld()
--
-- zmena globalni promenne
-- se projevi i ve volane funkci
worldStr=42
printWorld()

Návratové hodnoty funkcí
------------------------
-- funkce se dvema parametry,
-- ktera nevraci zadnou hodnotu
function repeatMessage(message, count)
    for i = 1, count do
        print(i, message)
    end
end
--
-- volani funkce
repeatMessage("Hello world!", 10)

Návratové hodnoty funkcí
------------------------
-- nerekurzivni vypocet faktorialu
-- (funkce s jednim parametrem vracejici taktez jednu hodnotu)
function factorial(n)
    local result = 1
    -- faktorial je definovan pouze pro prirozena cisla a nulu
    if n < 0 then
        return nil
    end
    for i = 1, n do
        result = result * i
    end
    return result
end
--
print("n", "n!")
for n = -5, 10 do
    print(n, factorial(n))
end

Návratové hodnoty funkcí
------------------------
-- funkce vracejici dve hodnoty: vysledek celociselneho
-- deleni a zbytek po celociselnem deleni
function divMod(x,y)
    return math.floor(x / y), x % y
end
--
print("n", "10/n", "zbytek")
for n = 1, 10 do
    x, y = divMod(10, n)
    print(n, x, y)
end

Volitelné parametry funkcí
--------------------------
function fce(x, y, z)
    print(x, y, z)
end
-- volani funkce fce s ruznym poctem parametru
fce(1, 2, 3)
fce(1, 2, 3, 4) -- posledni hodnota se nevyuzije
fce()
fce(42)
fce(42, 6502)
fce(nil, 6502)
-- lze pouzit i retezce popr. hodnoty dalsich typu typu
fce("Hello", "world", "!")
fce("Hello".." world", "!" )
fce("Hello".." world".."!" )

Proměnný počet parametrů
------------------------
-- funkce s dvojici pojmenovanych parametru
-- s moznosti pristupu k dalsim parametrum
-- pristupnym pres vyraz ...
function g(x, y, ...)
    -- pokud je seznam volitelnych parametru
    -- naplnen alespon jednou hodnotou,
    -- vypise se jeho delka
    if ... ~= nil then
        -- prevod na asociativni pole
        local varargs = {...}
        -- vypis delky pole
        print("vararg length: ", #varargs .. " items")
    end
    -- vypis obou pojmenovanych parametru
    -- i promennych parametru
    print(x, y, ...)
end
-- ukazka volani funkce
g()
g(1)
g(1,2)
g(1,2,3)
g(1,2,3,4)
g(1,2,3,5)
g("a", "b", "c", "d", "e")

Ukázkový příklad
----------------
-- funkce vracejici trojici:
-- 1. pocet prvku
-- 2. soucet prvku (suma)
-- 3. aritmeticky prumer jejich hodnot
function statistic(...)
   -- pokud nejsou zadany zadne parametry,
   -- neni nutne vypocet provadet
   if ... == nil then
       return 0, 0, 0
   end
   -- prevod seznamu parametru
   -- na asociativni pole
   items = {...}
   -- pocet prvku
   n = #items
   sum = 0
   -- vypocet sumy
   for i=1, n do
      sum = sum + items[i]
   end
   return n, sum, sum/n
end
--
print("n", "sum", "average")
print(statistic())
print(statistic(1, 2, 3, 4))
print(statistic(1, 1, 0, 0))
print(statistic(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))

Rekurze
-------
-- funkce pro rekurzivni vypocet faktorialu
function factorial(n)
    -- faktorial je definovan pouze pro prirozena cisla a nulu
    if n < 0 then
        return nil
    -- rekurze je ukoncena pri n=0
    elseif n == 0 then
        return 1
    else
        return n*factorial(n-1)
    end
end
-- vypis tabulky s faktorialy
print()
print("Factorial")
print("n", "n!")
for n = -5, 10 do
    print(n, factorial(n))
end

Rekurze
-------
-- rekurzivni vypocet binomickeho koeficientu
function binomical(n, k)
    if k == 0 then
        return 1
    else
        return binomical(n - 1, k - 1) * n / k;
    end
end
-- vypis nekterych hodnot "n nad k"
print()
print("Binomical coefficients")
print("n", "k", "n nad k")
for k = 0, 10 do
    for n = k, 10 do
        print(n, k, binomical(n, k))
    end
end

Funkce jako plnohodnotný datový typ
-----------------------------------
-- pomocna funkce, ktera vytiskne tabulku hodnot
-- pro uhly lezici mezi 0 az 90 stupni
-- na zaklade predane funkce
function printTable(func)
    -- tisk adresy funkce v adresnim prostoru VM
    print(func)
    -- tisk uhlu mezi 0 az 90 stupni
    -- a hodnot uzivatelske funkce pro tyto uhly
    -- (je nastaven krok po peti stupnich)
    for i=0, 90, 5 do
        -- prevod stupnu na radiany
        local alfa = math.pi * i / 180.0
        -- volani funkce predane jako parametr
        local y = func(alfa)
        print(string.format("%d\t%6.4f", i, y))
    end
end
--
-- uzivatelsky definovana funkce ulozena
-- do promenne "fce"
fce = function(x)
    return math.sin(x)
end
--
-- tisk tabulky
print("fce = function(x) return math.sin(x) end")
printTable(fce)
--
-- muzeme primo pouzit i knihovni funkci
-- se stejnym vyznamem
print("fce = math.sin")
printTable(math.sin)

Uzávěry
-------
-- Funkce obsahujici lokalni promennou.
-- Tato funkce vraci anonymni funkci
-- jako svuj vysledek.
function generateClosure()
    -- lokalni promenna, ktera neni
    -- z okolniho programu dostupna
    local y = 1
    -- anonymni funkce vytiskne hodnotu
    -- lokalni promenne funkce "generateClosure"
    -- a potom se pokusi o zmenu jeji hodnoty:
    return function()
        print(y)
        y = y + 1
    end
end
--
-- ziskame uzaver, tj. instanci anonymni funkce
closure1 = generateClosure()
--
-- jake hodnoty se vytisknou?
closure1()
closure1()
closure1()
closure1()

Uzávěry (2)
-----------
-- Funkce obsahujici lokalni promennou.
-- Tato funkce vraci anonymni funkci
-- jako svuj vysledek.
function generateClosure()
    -- lokalni promenna, ktera neni
    -- z okolniho programu dostupna
    local y = 1
    -- anonymni funkce vytiskne hodnotu
    -- lokalni promenne funkce "generateClosure"
    -- a potom se pokusi o zmenu jeji hodnoty:
    local result = function()
        print(y)
        y = y + 1
    end
    -- po vytvoreni zarodku uzaveru
    -- zmenime hodnotu lokalni promenne
    y = 42
    -- vratime vytvorenou funkci - uzaver
    return result
end
--
-- ziskame uzaver, tj. instanci anonymni funkce
closure = generateClosure()
--
-- vytiskne se posloupnost hodnot 42, 43, 44 a 45
closure()
closure()
closure()
closure()

Použití uzávěrů
---------------
-- pomocna funkce vracejici uzaver
function defPosloupnosti(n)
    -- pamatovana hodnota, ktera vsak
    -- neni z okolniho programu dostupna
    local y = 1
    -- pocitadlo volani = exponent
    local index = 0
    -- anonymni funkce vytiskne pamatovanou
    -- hodnotu a nakonec ji vynasobi zvolenou konstantou
    return function()
        print(index, y)
        y = y * n
        index = index + 1
    end
end
--
print("mocniny cisla 2")
-- ziskani uzaveru
generator = defPosloupnosti(2)
--
-- postupne se budou tisknout
-- mocniny cisla 2
for i=0, 16 do
    generator()
end
--
print("mocniny cisla 3")
-- ziskani uzaveru
generator = defPosloupnosti(3)
--
-- postupne se budou tisknout
-- mocniny cisla 3
for i=0, 16 do
    generator()
end

Lua v roli skriptovacího jazyka pro WWW stránky
-----------------------------------------------

